package Sem3;

// import java.util.ArrayList;

public class Piramid {
    public static int[] listFill(int n) {
        int[] list = new int[n];
        for (int index = 0; index < n; index++) {
            int a = (int) (Math.random()*20);
            list[index] = a;
        }
        return list;
    }
/* [19, 2, 13, 0, 18, 3]
 * 19(0)
 * 2 (1)        13(2)
 * 0(3) 18(4)   3(5)
 * index = n/2 - 1 = 2 => 13
 * Дальше что-то через что-то просеивается, смысл термина не ясен
 * Сравниваем правую ветку 13 больше 5
 * сравниваем левую ветку 18 больше 2 и 0 18 и 2 меняются местами
 * 19(0)
 * 18 (1)        13(2)
 * 0(3) 2(4)     3(5)
 * Сравниваем 19 18 и 13 всё ок.
 * Каждый дочерний элемент меньше родительского, вроде бы мы должны были этого добиться
 * 
 * берём последний элемент [n-1] это 3 и что-то делаем... меняем местами с первым
 * 3(0)
 * 18 (1)        13(2)
 * 0(3) 2(4)     19(5 заблокирован) 
 * сравниваем 3 18 13 и тот и другой больше трёх Видими, надо поменять с наибольшим
 * между 3 2 и 0 3 больше
 * 18(0)
 * 3 (1)        13(2)
 * 0(3) 2(4)     19(5 заблокирован) 
 * берём следующий последний элемент это 2 меняем местами с верхним
 * 2(0)
 * 3 (1)                       13(2)
 * 0(3) 18(4 заблокирован)     19(5 заблокирован) 
 * сравниваем 2 3 и 13 меняем 2 и 13
 * 13(0)
 * 3 (1)                       2(2)
 * 0(3) 18(4 заблокирован)     19(5 заблокирован) 
 * в ветке 3 и 0 3 больше
 * берём следующий последний элемент это 2 меняем местами с верхним
 * 0(0)
 * 3 (1)                                     2(2)
 * 13(3 заблокирован) 18(4 заблокирован)     19(5 заблокирован) 
 * среди 0 3 и 2 максимальное 3
 * 3(0)
 * 0 (1)                                     2(2)
 * 13(3 заблокирован) 18(4 заблокирован)     19(5 заблокирован) 
 * 
 * 2(0)
 * 0 (1)                                     3(2 заблокирован)
 * 13(3 заблокирован) 18(4 заблокирован)     19(5 заблокирован) 
 * 
 * 0(0)
 * 2(1 заблокирован)                         3(2 заблокирован)
 * 13(3 заблокирован) 18(4 заблокирован)     19(5 заблокирован) 
 * 
 * Кажется, я нашла рекурсию
 */
    public void sort(int arr[]){
        int n = arr.length;

        for (int i = n / 2 - 1; i >= 0; i--)/*Построение первой пирамиды по сути сортировка прогняется на первый раз чтобы сверху оказался максимальный*/
            piramidTraffic(arr, n, i);

        for (int i=n-1; i>=0; i--){/*Максимальный меняется с последним и прогоняется та же сортировка заново, чтобы сверху оказался максимальный. пока массив не кончится */
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            piramidTraffic(arr, i, 0);
        }
    }

    void piramidTraffic(int arr[], int n, int i){/* Сравнение родительского элемента с дочерними здесь n это текущее i функции sort, а i текущий родительский элемент*/
        int maxhere = i; 
        int l = 2*i + 1; /*левый*/
        int r = 2*i + 2; /*правый*/

        if (l < n && arr[l] > arr[maxhere]) /*Не выходим за границы массива и сравниваем с левым */
            maxhere = l;
        if (r < n && arr[r] > arr[maxhere])/*сравниваем с правым. Находим индекс максимального */
            maxhere = r;
        if (maxhere != i){/*Если индекс при предыдущем действии менялся, меняем местами сами элементы */
            int swap = arr[i];
            arr[i] = arr[maxhere];
            arr[maxhere] = swap;
            piramidTraffic(arr, n, maxhere); /*и так пока они не корчатся */
        }
    }

        static void printArray(int arr[])
        {
            int n = arr.length;
            for (int i=0; i<n; ++i)
                System.out.print(arr[i]+" ");
            System.out.println();
        }
    

    public static void main(String args[])
    {
        // int arr[] = {12, 11, 13, 5, 6, 7};
        int[] arr = listFill(8);
        printArray(arr);

        Piramid ob = new Piramid();
        ob.sort(arr);
        printArray(arr);
    }
    
}
